<template>
<v-container grid-list-md>
    <v-layout row wrap>
        <v-card xs12 class="content content-center">
            <v-toolbar class="file-toolbar">
                <v-text-field prepend-icon="search" v-model="searchTerm" hide-details single-line></v-text-field>
            </v-toolbar>
            <v-card-text>
                <div id="map" class="svg"></div>
            </v-card-text>
        </v-card>
    </v-layout>
</v-container>
</template>

<style scoped>
.toolbar__content>button.btn.btn--icon>.btn__content>i {
    color: rgba(0, 0, 0, 0.54);
}

.toolbar {
    padding-left: 10px;
    padding-right: 10px;
    background: white;
    box-shadow: none;
}

nav.toolbar.file-toolbar {
    background: white;
    box-shadow: none;
}

.file-toolbar {
    box-shadow: none;
    height: 56px;
}

.toolbar__content {
    background: white;
}

</style>

<script>
import * as d3 from 'd3';

export default {
    name: 'open-bubble',
    data() {
        return {
            searchTerm: '',
            data: [50, 90, 20, 100, 40, 50],
            linkData: null,
            line: ''
        }
    },
    mounted: function() {
        //Doc Ref Id: 9c80af62b1094bdfab633019b2d10c1e
        //this.updateMap('9c80af62b1094bdfab633019b2d10c1e');
        //All longs and lats 52f2468e05f743ca9911abe07c196363
        this.updateMap("52f2468e05f743ca9911abe07c196363");

        
    },
    created: function() {},
    methods: {
        updateMap(docRefId){
            let $this = this;
            $this.$http.get('https://pubtest.fileopen.com/api/analytics/file/' + docRefId).then(response => {
                $this.fileData = response.body;
                // NOTE: Data is an array of entries, this prints the first entry
                console.log($this.fileData);

                // NOTE: This is where I would call it calculate the data and create the graphic
                //       However, it currently uses static test data so it isn't necessary
                this.renderData($this.fileData);
            }, response => {
                console.error(response);
            });
        },
        renderData(sessionData){
            var width = 860;
            var height = 500;
            var maxRadius = 12;

            var n = 200,
                m = 10;

            var color = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(d3.range(m));

            // The largest node for each cluster.
            var clusters = new Array(m);

            var nodes = d3.range(n).map(function() {
              var i = Math.floor(Math.random() * m),
                  r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
                  d = {cluster: i, radius: r};
              if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
              return d;
            });
            console.log(nodes);


            var svg = this.makeSvg(width, height);

            var circle = svg.selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("r", function(d) { return d.radius; })
                .style("fill", function(d) { return color(d.cluster); });

        },
        makeSvg(width, height){
            var svg = d3.select("body")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append('g')
                .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');
            return svg;
        }

    }
}
</script>
